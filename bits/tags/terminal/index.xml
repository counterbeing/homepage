<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <docs>https://blogs.law.harvard.edu/tech/rss</docs>
    <title>terminal on Bits and Blocks</title>
    <link>https://www.corylogan.com/bits/tags/terminal/</link>
    <description>Recent content in terminal on Bits and Blocks</description>
    <ttl>1440</ttl>
    <generator>Hugo 0.55.6</generator>
    <language>en-us</language>
    <managingEditor> (Cory Logan)</managingEditor>
    <webMaster> (Cory Logan)</webMaster>
    <lastBuildDate>Wed, 22 May 2019 19:43:22 UT</lastBuildDate>
    <atom:link href="https://www.corylogan.com/bits/tags/terminal/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Serving Localhost to the Web with Reverse Ssh Tunnels</title>
      <link>https://www.corylogan.com/bits/bits/serving-localhost-to-the-web-with-reverse-ssh-tunnels/</link>
      <pubDate>Mon, 10 Jul 2017 13:12:03 UT</pubDate>
      <dc:creator>Cory Logan</dc:creator>
      <guid>https://www.corylogan.com/bits/bits/serving-localhost-to-the-web-with-reverse-ssh-tunnels/</guid>
      <description>Note: If you don&amp;rsquo;t have a server already, check my last tip.
This topic is always a little tricky, so, here&amp;rsquo;s the basic thing to know, as this is the most frequent use case.
Suppose you have a development rails server running on your local computer. You can access this server via curl http://localhost:3000. Which is to say, it&amp;rsquo;s running on your localhost, on port 3000. You want your client to see it, to give you feedback, but they&amp;rsquo;re nowhere near you, and you just want a quick way to show it to them.</description>
      <category domain="https://www.corylogan.com/categories/technology">Technology</category>
      <content:encoded><![CDATA[ Note: If you don&amp;rsquo;t have a server already, check my last tip.
This topic is always a little tricky, so, here&amp;rsquo;s the basic thing to know, as this is the most frequent use case.
Suppose you have a development rails server running on your local computer. You can access this server via curl http://localhost:3000. Which is to say, it&amp;rsquo;s running on your localhost, on port 3000. You want your client to see it, to give you feedback, but they&amp;rsquo;re nowhere near you, and you just want a quick way to show it to them.
Fortunately for you, you know about ssh. You know that it will take you just a few seconds to set up a reverse tunnel through an intermediate server. Cake! Huh?
Things you&amp;rsquo;ll need, and their values in my example:
 Some kind of server on the web running sshd (yourserver.com) A local webserver accessible (0.0.0.0:3000)  ssh -NR 3333:localhost:3000 user@yourserver.com Now that the tunnel is running, you should be able to access your web server at http://yourserver.com:3333. You can of course change either of the ports. There are a few caveats, but this is it in the basic form.
Troubleshooting If that&amp;rsquo;s not working for you, chances are you need the GatewayPorts yes option added to the file /etc/ssh/sshd_config on the server. Go in there and add that line, then restart the ssh service. With ubuntu that&amp;rsquo;s just sudo service ssh restart.
Tips  You can run this in the background if you want by adding the -f flag. I prefer to run it in the foreground when I&amp;rsquo;m just using it for a moment, or troubleshooting as it&amp;rsquo;s easier to kill. If you run it in the background, and you just try to run it again on the same port, they will collide, and you will fail. Lower port numbers (lower than 1024) can&amp;rsquo;t be used unless you&amp;rsquo;re a super user on the system. Generally, it&amp;rsquo;s just easier to use a higher port number on the remote server. The -v flag will give you the full ssh output with authentication. This is another common source of problems. If you have a few dollars, and not much interest in the topic, check out ngrok, it&amp;rsquo;s a great tool that really takes most of the trouble out of it. It also means you don&amp;rsquo;t need to bring your own server! If you don&amp;rsquo;t wish to run your own server, this is the way to go.  ]]></content:encoded>
    </item>
    <item>
      <title>Saving Time With Tmux</title>
      <link>https://www.corylogan.com/bits/bytes/saving-time-with-tmux/</link>
      <pubDate>Mon, 10 Jul 2017 11:45:28 UT</pubDate>
      <dc:creator>Cory Logan</dc:creator>
      <guid>https://www.corylogan.com/bits/bytes/saving-time-with-tmux/</guid>
      <description>What is a terminal multiplexer, and why do I care? When you split up a terminal screen into sub-terminals, that&amp;rsquo;s called terminal multiplexing. This is nothing new, GNU Screen has been around since 1987. Tmux is just screen&amp;rsquo;s younger, nubile cousin. I&amp;rsquo;m about to explain how this simple technology can:
 Keep you organized. Lower the bar to get to work. Save you time. Enable teamwork.  Here&amp;rsquo;s a quick demonstration:</description>
      <content:encoded><![CDATA[ What is a terminal multiplexer, and why do I care? When you split up a terminal screen into sub-terminals, that&amp;rsquo;s called terminal multiplexing. This is nothing new, GNU Screen has been around since 1987. Tmux is just screen&amp;rsquo;s younger, nubile cousin. I&amp;rsquo;m about to explain how this simple technology can:
 Keep you organized. Lower the bar to get to work. Save you time. Enable teamwork.  Here&amp;rsquo;s a quick demonstration: 
Multiple panes for multiple things If you watch the demo above, you can see that you can make multiple panes, and multiple windows. You can organize them however you like.
The benefit of this is that you can have a server running in one pane, and an editor running on another. Or your test suite. Or whatever else you need to keep an eye on.
You might think, well, I can already do that in my terminal app. And maybe you can! But, can you do it on remote servers over ssh? And can you keep those panes running even if you quit your terminal app? Didn&amp;rsquo;t think so.
Keep your workspace tidy What if, every time you went to start working on your app, your text editor opened, your test suite ran, git pulled the latest changes, and a development server launched? If that gets you at all excited, you should check out tmuxinator. There are other options out there that do the same thing. But, with a simple configuration file, you can have all that and more!
Work on remote servers Sometimes when working on a remote server, it&amp;rsquo;s useful to keep a long running task going, or at least be able to look at the same workspace you were looking at previously. By keeping your work in a tmux session, you can simply rejoin the session you were previously using. Everything is now exactly as you left it!
I realize it&amp;rsquo;s not the best use, but there have been a couple of times I&amp;rsquo;ve used tmux to keep a long running task going in the background on a server. This way, when I close my laptop and walk away, everything keeps running. Imagine a long rake task, sure I could have put it in a background job, but it was a one off task, and writing the job would have been unnecessary work.
Collaborate You can have more than one person in a tmux session at once. This has to be one of the greatest things of all about tmux. It&amp;rsquo;s like screen sharing, but so much faster, as it&amp;rsquo;s just over an ssh session. There is nothing worse than trying to collaborate over a slow VNC screen share, it&amp;rsquo;s like typing with boxing gloves. There are a few hoops to jump through, another user, ssh access, and permissions&amp;hellip; But there&amp;rsquo;s another option.
Tmate is a fantastically handy little utility that does all of the hoop jumping for you. After installing tmate, just run it, and give your friend access by copying your secure ssh command. Even from the other side of the world, you can have lag-free collaboration!
Next steps Go give tmux a shot!
You&amp;rsquo;ll need to learn some of the basic commands for getting around, and probably do a little customization. Good luck!
]]></content:encoded>
    </item>
    <item>
      <title>What Process Is Hogging My Port On Mac Os</title>
      <link>https://www.corylogan.com/bits/bits/what_process_is_hogging_my_port_on_mac_os/</link>
      <pubDate>Thu, 15 Dec 2016 19:51:29 UT</pubDate>
      <dc:creator>Cory Logan</dc:creator>
      <guid>https://www.corylogan.com/bits/bits/what_process_is_hogging_my_port_on_mac_os/</guid>
      <description>Address already in use Damn. Did I leave a server running somewhere? Sometimes you&amp;rsquo;re not sure where you left a server running, or where something is running you never knew about. I&amp;rsquo;m finally writing this down, as I always have to look it up. I found this solution in a StackOverflow post.
Here&amp;rsquo;s how to get all of the processes by what port they&amp;rsquo;re using.
sudo lsof -iTCP -sTCP:LISTEN -n -P As A Shell Function Looking at it, I realized I would never remember it, given how infrequently I need it.</description>
      <category domain="https://www.corylogan.com/categories/technology">Technology</category>
      <content:encoded><![CDATA[ Address already in use Damn. Did I leave a server running somewhere? Sometimes you&amp;rsquo;re not sure where you left a server running, or where something is running you never knew about. I&amp;rsquo;m finally writing this down, as I always have to look it up. I found this solution in a StackOverflow post.
Here&amp;rsquo;s how to get all of the processes by what port they&amp;rsquo;re using.
sudo lsof -iTCP -sTCP:LISTEN -n -P As A Shell Function Looking at it, I realized I would never remember it, given how infrequently I need it. So, I wrote a function. You should be able to pop this into your .bashrc or .zshrc, or whatever you&amp;rsquo;re using.
function whats_using { if [ -z $1 ]; then sudo lsof -iTCP -sTCP:LISTEN -n -P else sudo lsof -iTCP -sTCP:LISTEN -n -P | grep $1 fi } Now you can search for what&amp;rsquo;s using a port like so, or don&amp;rsquo;t specify a port number to return all results.
âžœ whats_using 8181 com.docke 4082 cory 20u IPv4 0xa05b24c922aef1a1 0t0 TCP *:8181 (LISTEN) com.docke 4082 cory 21u IPv6 0xa05b24c91a710329 0t0 TCP [::1]:8181 (LISTEN)]]></content:encoded>
    </item>
  </channel>
</rss>
