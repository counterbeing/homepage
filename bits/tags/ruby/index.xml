<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <docs>https://blogs.law.harvard.edu/tech/rss</docs>
    <title>ruby on Bits and Blocks</title>
    <link>https://www.corylogan.com/bits/tags/ruby/</link>
    <description>Recent content in ruby on Bits and Blocks</description>
    <ttl>1440</ttl>
    <generator>Hugo 0.55.6</generator>
    <language>en-us</language>
    <managingEditor> (Cory Logan)</managingEditor>
    <webMaster> (Cory Logan)</webMaster>
    <lastBuildDate>Wed, 22 May 2019 18:49:46 UT</lastBuildDate>
    <atom:link href="https://www.corylogan.com/bits/tags/ruby/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Comparing Performance of Ruby and Golang With a Benchmark</title>
      <link>https://www.corylogan.com/bits/bits/comparing-performance-of-ruby-and-golang-with-a-benchmark/</link>
      <pubDate>Tue, 21 May 2019 20:39:32 UT</pubDate>
      <dc:creator>Cory Logan</dc:creator>
      <guid>https://www.corylogan.com/bits/bits/comparing-performance-of-ruby-and-golang-with-a-benchmark/</guid>
      <description>I recently solved a coding challenge using Ruby. I&amp;rsquo;ve been curious for some time about coding using Golang, and so I decided to port it over, and see what the performance difference was.
I made a small adaption for a better comparison. I&amp;rsquo;m now using a grid that has 100_000_000 squares on it. This is definitely a bit of work.
The code package main import ( &amp;#34;encoding/json&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;io/ioutil&amp;#34; &amp;#34;os&amp;#34; ) var grid [][]int var gridDim [2]int var a = make(map[[2]int]bool) func main() { jsonFile, err := ioutil.</description>
      <content:encoded><![CDATA[ I recently solved a coding challenge using Ruby. I&amp;rsquo;ve been curious for some time about coding using Golang, and so I decided to port it over, and see what the performance difference was.
I made a small adaption for a better comparison. I&amp;rsquo;m now using a grid that has 100_000_000 squares on it. This is definitely a bit of work.
The code package main import ( &amp;#34;encoding/json&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;io/ioutil&amp;#34; &amp;#34;os&amp;#34; ) var grid [][]int var gridDim [2]int var a = make(map[[2]int]bool) func main() { jsonFile, err := ioutil.ReadFile(os.Args[1]) if err != nil { fmt.Println(err) } json.Unmarshal([]byte(jsonFile), &amp;amp;grid) gridDim[0] = len(grid) gridDim[1] = len(grid[0]) greatest := 0 for rowIndex, row := range grid { for colIndex := range row { currentKey := [2]int{rowIndex, colIndex} _, hasKey := a[currentKey] if hasKey { continue } a[currentKey] = true total := findCluster(currentKey, true) if total &amp;gt; greatest { greatest = total } } } fmt.Println(greatest) } func getValFromGrid(coords [2]int) int { return grid[coords[0]][coords[1]] } func findCluster(coords [2]int, first bool) int { currentValue := getValFromGrid(coords) adjascentSquares := [4][2]int{ {coords[0] - 1, coords[1]}, {coords[0], coords[1] - 1}, {coords[0] &#43; 1, coords[1]}, {coords[0], coords[1] &#43; 1}, } total := 1 for _, v := range adjascentSquares { _, hasKey := a[v] if hasKey { continue } if withinGrid(v) &amp;amp;&amp;amp; hasSameValue(currentValue, v) { a[v] = true total = total &#43; findCluster(v, false) } } return total } func hasSameValue(val int, coords [2]int) bool { return getValFromGrid(coords) == val } func withinGrid(coords [2]int) bool { return coords[0] &amp;gt;= 0 &amp;amp;&amp;amp; coords[0] &amp;lt; gridDim[0] &amp;amp;&amp;amp; coords[1] &amp;gt;= 0 &amp;amp;&amp;amp; coords[1] &amp;lt; gridDim[1] } The Benchamrk ruby run.rb gen_grid_10000.json 933.50s user 26.53s system 95% cpu 16:45.07 total ./grid gen_grid_10000.json 97.89s user 4.45s system 98% cpu 1:43.81 total  As you can see from the above. Golang did the job at a remarkable 10x the rate of the Ruby implementation. The tradeoff is just that it&amp;rsquo;s more annoying to write. I&amp;rsquo;ll probably stick to ruby for most things, but golang is clearly worth consideration when there&amp;rsquo;s a problem that requires a performance boost!
]]></content:encoded>
    </item>
    <item>
      <title>Proving the Monty Hall Problem</title>
      <link>https://www.corylogan.com/bits/bits/proving-the-monty-hall-problem/</link>
      <pubDate>Tue, 21 May 2019 04:35:16 UT</pubDate>
      <dc:creator>Cory Logan</dc:creator>
      <guid>https://www.corylogan.com/bits/bits/proving-the-monty-hall-problem/</guid>
      <description>Doors    When I first heard of the Monty Hall problem, I read about it in Sam Harris&amp;rsquo; The Moral Landscape, and it took me a few minutes to really wrap my brain about it. Talking about it with a few people since, I struggle to convince them that this really works this way. I think part of it is that I still don&amp;rsquo;t quite believe it.</description>
      <content:encoded><![CDATA[   Doors    When I first heard of the Monty Hall problem, I read about it in Sam Harris&amp;rsquo; The Moral Landscape, and it took me a few minutes to really wrap my brain about it. Talking about it with a few people since, I struggle to convince them that this really works this way. I think part of it is that I still don&amp;rsquo;t quite believe it. Which is why I&amp;rsquo;m going to write a program that can run the problem over and over to show wether or not the Monty Hall problem actually has a solution.
The Monty Hall Problem Itself Imagine you are a gameshow contestant standing in front of three doors. You know that behind one door is a pile of money and the other two doors, there is nothing. You then pick one door, let&amp;rsquo;s say door A. After selecting a door, the game show host points to one of the other two doors, door B, and tells you that this door does not contain the prize. At this point you are offered the opportunity to switch doors from door A to door C, or stick with your original choice of door A.
Should you switch? What are the odds if you do or don&amp;rsquo;t switch?
If you keep reading you&#39;ll read the answer and the solution, if you want a minute to think about it for yourself, pause here.  To most people, it appears obvious that you have 50&amp;frasl;50 odds in this case. But in fact, you should always switch. If you don&amp;rsquo;t switch, your odds of winning are 1&amp;frasl;3, and if you do, your odds are 2&amp;frasl;3.
You should always switch.
Explanation of why this works When you first guess at a door your odds are exactly 1/3. So your odds of picking wrong are 2/3. Once one door is eliminated, it&amp;rsquo;s still true that your probably picked incorrectly, thus, you should switch doors.
Code to Prove It Here we run the experiment a million times to show what the odds really are.
def gameshow(switch) doors = [1, 0, 0].shuffle choice = rand(3) removed_door = [0,1,2] .reject { |d| d == choice } .filter { |d| doors[d] == 0 } .sample switched_choice = [0, 1, 2] .reject { |d| removed_door == d || choice == d } .first choice = switched_choice if switch doors[choice] end def run_experiment switch_results = 1_000_000.times.map do gameshow(true) end.sum / 10_000.0 stay_results = 1_000_000.times.map do gameshow(false) end.sum / 10_000.0 puts &amp;#34;By switching you won #{switch_results}&amp;#34; puts &amp;#34;By staying you won #{stay_results}&amp;#34; end run_experiment This returns as anticipated:
By switching you won 66.6246 By staying you won 33.3209  A more in depth explanation   ]]></content:encoded>
    </item>
    <item>
      <title>Find Adjascent Squares for a Coding Challenge</title>
      <link>https://www.corylogan.com/bits/bits/find-adjascent-squares-for-a-coding-challenge/</link>
      <pubDate>Mon, 20 May 2019 05:11:59 UT</pubDate>
      <dc:creator>Cory Logan</dc:creator>
      <guid>https://www.corylogan.com/bits/bits/find-adjascent-squares-for-a-coding-challenge/</guid>
      <description>Random grid of numbers.    I spotted a challenge that was something like this online, and I adapted it. There was something that I wanted to understand a little bit better. The interesting thing here is about the data structures used, to increase efficiency.
Find Contiguous Squares Imagine you have a grid of n width and height, and it&amp;rsquo;s populated with random numbers. It could be represented something like this:</description>
      <content:encoded><![CDATA[   Random grid of numbers.    I spotted a challenge that was something like this online, and I adapted it. There was something that I wanted to understand a little bit better. The interesting thing here is about the data structures used, to increase efficiency.
Find Contiguous Squares Imagine you have a grid of n width and height, and it&amp;rsquo;s populated with random numbers. It could be represented something like this:
[ [1, 1, 2, 2, 1, 1, 1, 2, 1, 2], [1, 0, 0, 2, 1, 1, 2, 2, 0, 2], [0, 1, 0, 1, 2, 1, 0, 1, 2, 2], [2, 1, 2, 1, 0, 0, 0, 2, 1, 0], [0, 2, 1, 2, 1, 1, 2, 1, 2, 0], [1, 1, 1, 2, 1, 1, 0, 0, 2, 1], [1, 2, 1, 2, 2, 2, 2, 1, 2, 1], [2, 1, 1, 2, 2, 1, 2, 0, 1, 1], [0, 1, 1, 2, 2, 0, 1, 0, 2, 2], [2, 2, 2, 1, 0, 1, 1, 0, 2, 2] ] In fact, that&amp;rsquo;s the exact grid that the image is of above.
Now, you need to write a program that accepts the grid and returns the greatest number of contiguous squares that have the same value. In this case, the function should return 11. If you look for a moment you&amp;rsquo;ll find the cluster of 11 orange squares, it&amp;rsquo;s pretty trivial for the human brain to do.
But, let&amp;rsquo;s expand this to say, a million squares. The following program can do this on my computer in about 5 seconds.
class GridChecker def initialize(grid) @assessed = {} @grid = grid end def run greatest = 0 @grid.each_with_index do |row, ri| row.each_with_index do |_col, ni| coords = [ri, ni] next if @assessed.key?(coords) cluster_size = check_square(coords) greatest = cluster_size if cluster_size &amp;gt; greatest end end greatest end def check_square(coords) @assessed[coords] = nil find_cluster(coords) end def find_cluster(coords) total = 1 adjascent_squares(coords).map do |adjascent_coords| next if @assessed.key?(adjascent_coords) @assessed[adjascent_coords] = nil total &#43;= find_cluster(adjascent_coords) end total end def adjascent_squares(coords) neighbor_coords(*coords).filter do |x| within_grid(*x) &amp;amp;&amp;amp; @grid[x[0]][x[1]] == @grid[coords[0]][coords[1]] end end def within_grid(row, col) row &amp;gt;= 0 &amp;amp;&amp;amp; row &amp;lt; grid_height &amp;amp;&amp;amp; col &amp;gt;= 0 &amp;amp;&amp;amp; col &amp;lt; grid_width end def grid_width @grid_width ||= @grid[0].length end def grid_height @grid_height ||= @grid.length end def neighbor_coords(row, col) [ [row - 1, col], [row, col - 1], [row &#43; 1, col], [row, col &#43; 1] ] end end The Twist Here&amp;rsquo;s the thing that surprised me a little bit, and took some learning. I&amp;rsquo;ve always thought about arrays as being simpler data structures than hashes (or objects or libraries depending on your language), and so in my mind I had just taken for granted that using them was more efficient for many things. But this simple task very quickly demonstrats that this is not the case.
The key here is that in the @assessed instance variable, I&amp;rsquo;ve used a hash rather than an Array. It&amp;rsquo;s easy to use either in this case. It feels weird to be assigning arbitrary nil values that aren&amp;rsquo;t even used for anything. But the thing is that the look up time on this ever growing variable is so much faster when using a hash, and it doesn&amp;rsquo;t slow down the way it does with an array. Using an array for the same thing means that you have to iterate over it repeatedly, leading to a huge slow down as you add more data.
Something Else to Play with Here&amp;rsquo;s a quick script to generate a grid of n dimensions to play with. It&amp;rsquo;s a quick way to get started with your own implementation, or to play with performance.
require &amp;#39;json&amp;#39; def gen_grid(n) n.times.map do n.times.map do rand(3) end end end File.write(&amp;#39;grid.json&amp;#39;, gen_grid(1000).to_json)]]></content:encoded>
    </item>
    <item>
      <title>A Single Singleton in Ruby</title>
      <link>https://www.corylogan.com/bits/bytes/a-single-singleton-in-ruby/</link>
      <pubDate>Wed, 14 Dec 2016 02:22:26 UT</pubDate>
      <dc:creator>Cory Logan</dc:creator>
      <guid>https://www.corylogan.com/bits/bytes/a-single-singleton-in-ruby/</guid>
      <description>The singleton design pattern I&amp;rsquo;m relatively new the the concept of the singleton, even though I&amp;rsquo;ve been programming for a number of years. I&amp;rsquo;ve run into several instances in which I new that this was exactly what I needed, but did not have a name for it. Here, I&amp;rsquo;m going to try to explain it to myself a year ago. There are a few questions I&amp;rsquo;ll try to address.</description>
      <content:encoded><![CDATA[ The singleton design pattern I&amp;rsquo;m relatively new the the concept of the singleton, even though I&amp;rsquo;ve been programming for a number of years. I&amp;rsquo;ve run into several instances in which I new that this was exactly what I needed, but did not have a name for it. Here, I&amp;rsquo;m going to try to explain it to myself a year ago. There are a few questions I&amp;rsquo;ll try to address.
 Why do I care? What does it do? How should I implement it?  Why do I care? A lot has been written on design patterns, and by people with a lot more experience than myself. I&amp;rsquo;d recommend picking up a book on the topic and learning a bit more if it&amp;rsquo;s a new concept to you. Each one of these patterns is a tool that you can use to solve problems that have been solved over and over again. They can hasten, and solidify your development, as well as give you a way to succinctly communicate big ideas.
This particular pattern generally comes into play when you need some kind of global object to not only provide a set of methods, but also manage some kind of global state.
What does it do? I&amp;rsquo;ll give you a real world example to help make the point. In working on an application that was in charge of sifting through large piles of data, and alerting a person for errors several times a day, I needed a way to keep track of the errors in memory. It also needed to be available to many different classes in the application.
The singleton fits this almost perfectly.
I&amp;rsquo;ll admit, there are many cases when it&amp;rsquo;s a poor choice for the pattern to use. Any time you only need state for a little while, or if you need more than a handful of methods on an object.
In essence, the singleton is for simple objects that are action based, and that you only want one of in the instance of your application.
How should I implement it? There are different ways to implement the singleton pattern. Let&amp;rsquo;s first go over an example of the pattern implemented by hand, so that you can see how it works, before we try to hide some of the details. We&amp;rsquo;ll stick with the error logger example.
class ErrorLogger # This prevents the class from being instantiated. With a singleton, we don&amp;#39;t # want more than one instance. That&amp;#39;s pretty much the definition. private_class_method :new # This class variable will be in charge of storing the global state of our # singleton in memory. All of the information will end up here. We&amp;#39;ll access # it through another method of our choosing. @@log = [] # Everything inside of this will be declared as a class method. class &amp;lt;&amp;lt; self def log_an_error(error) @@log &amp;lt;&amp;lt; error end def print_log @@log.inspect end end end ErrorLogger.log_an_error(&amp;#39;Server is on fire!&amp;#39;) ErrorLogger.print_log # =&amp;gt; [&amp;#34;Server is on fire&amp;#34;] There are other implementations of the singleton, but I prefer to simply have the class expose any methods directly on itself. Some other singletons have the class create a single instance of itself, and all methods are instance methods, and in that case you can use instance variables.
But, this can be simplified further with the help of ruby&amp;rsquo;s built in singleton module. The one gotcha here, is that calling it behaves a little differently. These are now instance methods and must be called on the instance.
require &amp;#39;singleton&amp;#39; class ErrorLogger include Singleton def initialize @log = [] end def log_an_error(error) @log &amp;lt;&amp;lt; error end def print_log @log.inspect end end error_logger = ErrorLogger.instance error_logger.log_an_error(&amp;#39;Killing me softly...&amp;#39;) error_logger.print_log # =&amp;gt; [&amp;#34;Killing me softly...&amp;#34;] In my opinion, it doesn&amp;rsquo;t look much better than the first example. But, it does avoid the use of class variables, which is nice.
I think though, the one that I&amp;rsquo;ll probably reach for next time, is using module methods on a module. I know that this overlooks a few things, like the fact that modules can be mixed into classes, and you don&amp;rsquo;t really want that with a singleton. But, I&amp;rsquo;d say, in all practical terms, just don&amp;rsquo;t do that.
module ErrorLogger class &amp;lt;&amp;lt; self def log @log ||= [] end def log_an_error(error) log &amp;lt;&amp;lt; error end def print_log log.inspect end end end ErrorLogger.log_an_error(&amp;#39;Whoops!&amp;#39;) ErrorLogger.print_log # =&amp;gt; [&amp;#34;Whoops!&amp;#34;] There are other great articles that dive further into the topic. I&amp;rsquo;d really recommend Practicing Ruby&amp;rsquo;s take on the topic.
]]></content:encoded>
    </item>
    <item>
      <title>The Mysteries of the Ruby Heredoc</title>
      <link>https://www.corylogan.com/bits/bytes/the_mysteries_of_the_ruby_heredoc/</link>
      <pubDate>Fri, 18 Nov 2016 17:28:41 UT</pubDate>
      <dc:creator>Cory Logan</dc:creator>
      <guid>https://www.corylogan.com/bits/bytes/the_mysteries_of_the_ruby_heredoc/</guid>
      <description>As of writing this, I&amp;rsquo;m running Ruby version 2.3.0. Not all of this, particularly the stripped heredoc, is available in plain ruby before 2.3.0.
Heredoc Basics So, you need a string that&amp;rsquo;s longer than a line, and you&amp;rsquo;re sick of quotes and backslashes? And you might like to retain formatting? You want string interpolation too? Enter, heredoc.
Here&amp;rsquo;s your basic, run of the mill, heredoc. You&amp;rsquo;ll notice we use the &amp;lt;&amp;lt;- operator, and our safe-word, which we will use to end the heredoc.</description>
      <content:encoded><![CDATA[ As of writing this, I&amp;rsquo;m running Ruby version 2.3.0. Not all of this, particularly the stripped heredoc, is available in plain ruby before 2.3.0.
Heredoc Basics So, you need a string that&amp;rsquo;s longer than a line, and you&amp;rsquo;re sick of quotes and backslashes? And you might like to retain formatting? You want string interpolation too? Enter, heredoc.
Here&amp;rsquo;s your basic, run of the mill, heredoc. You&amp;rsquo;ll notice we use the &amp;lt;&amp;lt;- operator, and our safe-word, which we will use to end the heredoc.
def print_a_haiku haiku = &amp;lt;&amp;lt;-TEXT ruby is pretty the formatting perfected lovely indented TEXT puts haiku end print_a_haiku That would simply return the text as expected:
ruby is pretty the formatting perfected lovely indented This works, but it&amp;rsquo;s clearly ugly. When you see it in a piece of code you&amp;rsquo;re trying to navigate, it&amp;rsquo;s more than a little disorienting. You could actually indent the text above, but, if you do that the string returned will also have leading spaces. In some cases, leading spaces can break things in unexpected ways.
Stripped Heredocs One thing that drives me nuts, is when I&amp;rsquo;m reading some code that contains heredocs, and suddenly you&amp;rsquo;re all the way unindented. While in many cases this might be an indicator that something is wrong, there are many places I think it&amp;rsquo;s acceptable, and even preferable to have an indented heredoc.
As of Ruby 2.3, we have a new way to handle this. We declare the heredoc using the &amp;lt;&amp;lt;~ operator.
def print_a_haiku haiku = &amp;lt;&amp;lt;~TEXT ruby is pretty the formatting perfected lovely indented TEXT puts haiku end It&amp;rsquo;s a small thing, but these little niceties really help when trying to internalize a complicated file quickly.
The Rails Way Long before ruby featured a stripped heredoc, Rails saw the need and implemented their own method. Here is their implementation, which was added as an extension of String.
class String def strip_heredoc indent = scan(/^[ \t]*(?=\S)/).min.try(:size) || 0 gsub(/^[ \t]{#{indent}}/, &amp;#39;&amp;#39;) end end This counts the minimum number of spaces before all lines of your heredoc, and indents accordingly. You&amp;rsquo;d use it like so.
puts &amp;lt;&amp;lt;-MY_STRING.strip_heredoc  here is some text and indented once here MY_STRING I mention this in part, because I found it useful, and you might find it useful if you&amp;rsquo;re on an earlier version of ruby. If you&amp;rsquo;re 2.3 or later, I would prefer the Ruby implementation.
There&amp;rsquo;s another reason this is worth looking at. It demonstrates how to extend string and write your own heredoc formatter.
My Own Bastardization It feels like I should feel guilty whenever I even consider adding an extension to a core class. I don&amp;rsquo;t though. But, I will offer a caveat. Don&amp;rsquo;t go monkey patching carelessly! Be sure you&amp;rsquo;re not overwriting anything important, or you&amp;rsquo;ll be in a world of hurt.
I, for one, believe that monkey patching can be done in respectable ways.
Enough with the warnings. Here&amp;rsquo;s the use case that got me thinking about it. Recently, I&amp;rsquo;ve been having frequent need to test the output of various CSVs. There are various ways to do this&amp;hellip; I could have fixtures, but that&amp;rsquo;s a lot of fixtures to manage. I could simply let the lines run on long, but that&amp;rsquo;s very difficult to read, and even more difficult to format. It&amp;rsquo;s a monkey patch for string that allows you to write in a clearer format, that allows you to respect line length limitations.
Take a CSV for example, but, also imagine it&amp;rsquo;s much wider.
first_name,last_name,favorite_hobby,favorite_color,favorite_food,favorite_kind_of_motorcycle Cory,Logan,climbing,red,pizza,drz400 Paul,Baker,reading,blue,cheese,klr650  So, we could just stuff it in a heredoc and call it done, but that leaves the line length too long to look at on one screen. If you&amp;rsquo;re running something like rubocop, you probably have a line length limit to contend with as well.
So, here it is with a specially formatted heredoc, in which, two line breaks equal one. Allowing you to break lines, wherever, as long as you don&amp;rsquo;t need two.
csv_string = &amp;lt;&amp;lt;-CSV.csv_doc 	first_name,last_name,favorite_hobby,favorite_color, favorite_food,favorite_kind_of_motorcycle Cory,Logan,climbing,red,pizza,drz400 Paul,Baker,reading,blue,cheese,klr650 CSV It&amp;rsquo;s worth noting what&amp;rsquo;s actually happening here, as I&amp;rsquo;d never seen the syntax for calling a method on the result of a heredoc before. The &amp;lt;&amp;lt;-CSV part, is just your regular heredoc, it&amp;rsquo;s saying that the end of the string is at the next occurrence of the text CSV, which you will find at the end. Then, the method csv_doc is called on the resulting instance of String.
This formatting is all about being able to read it in the context of code or a test. In order to achieve this formatting, this is where the monkey patch comes in.
class String def csvdoc stripped = strip_heredoc.gsub(/\n(?!\n)/, &amp;#39;&amp;#39;) &amp;#34;#{stripped}\n&amp;#34; end end This also inserts an extra empty line at the end of the string, to make it a valid CSV. This could be modified to many different cases. I&amp;rsquo;ve just been running into the CSV example a lot. And if you&amp;rsquo;re really not into monkey patching, you might consider implementing it as a standalone method that you pass a string to.
Have fun!
]]></content:encoded>
    </item>
  </channel>
</rss>
